# Arquitectura de software: Capas, Componentes y Acoplamiento

> Capas organizan responsabilidades por niveles de abstracción; componentes encapsulan funcionalidades con interfaces claras. Diseñar dependencias hacia contratos (no implementaciones) reduce impacto del cambio, mejora testeabilidad y acelera la entrega.

## Objetivos
- Entender capas vs. componentes y su relación con el acoplamiento.
- Identificar señales de alto y bajo acoplamiento.
- Conectar estos conceptos con patrones de diseño y prácticas comunes.

---

## Capas

Las capas son agrupaciones horizontales por nivel de abstracción. Cada capa ofrece servicios a la superior y consume de la inferior.

- Presentación (UI): interacción con el usuario, validación superficial, formato de salida.
- Aplicación (Casos de uso): orquestación de flujos, coordinación de servicios.
- Dominio (Reglas): invariantes y políticas del negocio, entidades/valores.
- Infraestructura/Datos: DB, archivos, APIs, colas, proveedores.

Principios prácticos:
- Dependencias unidireccionales (UI → Aplicación → Dominio → Infraestructura).
- Evitar “saltos” de capas (UI no accede directo a DB).
- Exponer contratos estables entre capas (interfaces/DTOs/vistas SQL).

---

## Componentes

Un componente es una unidad cohesionada y sustituible con una interfaz pública.

- Propiedades: alta cohesión, bajo acoplamiento, límites explícitos.
- Ejemplos por capa:
  - Presentación: OrderController, CheckoutForm.
  - Aplicación: OrderService, PricingService.
  - Dominio: Order, Money, DiscountPolicy.
  - Infraestructura: OrderRepository, EmailAdapter, PaymentGatewayClient.

Buenas prácticas:
- Dependencias hacia interfaces (puertos), no clases concretas.
- Inyección de dependencias en el punto de composición.
- Tests aislados por componente.

---

## Acoplamiento

- Alto acoplamiento: un módulo conoce detalles internos de otro (clases concretas, nombres de columnas, SDKs). Cambiar una pieza rompe muchas.
- Bajo acoplamiento: un módulo depende de un contrato estable (interface/DTO/view/función). Cambios se encapsulan en adaptadores o definiciones internas.

Señales de alto acoplamiento:
- UI con SQL/ORM/SDKs directos.
- Controladores que devuelven entidades ORM crudas a la vista.
- Repositorios que filtran detalles de proveedor a la lógica de negocio.

Señales de bajo acoplamiento:
- Interfaces de repositorios/servicios, adaptadores por proveedor.
- Contratos versionados de datos (v1, v2).
- Composición externa (DI) para intercambiar implementaciones.

---

### Ejemplo C# (alto vs. bajo acoplamiento)
Acoplado (UI depende de clase concreta):

```csharp

public class Names
{
    // detalles en memoria
}

public class MySystem
{
    private readonly Names _names; // dependencia concreta

    public MySystem(Names names)
    {
        _names = names;
    }

    public void Run()
    {
        _names.Save("Ana");
        foreach (var n in _names.Get())
        {
            /* ... */
        }
    }
}

```

Desacoplado (UI depende de una interfaz):

```csharp

public interface IRepository
{
    void Save(string name);
    IEnumerable<string> Get();
}

public class Names : IRepository
{
    // List
    public void Save(string name)
    {
        /* ... */
    }

    public IEnumerable<string> Get()
    {
        /* ... */
        yield break;
    }
}

public class NamesUnique : IRepository
{
    // HashSet
    public void Save(string name)
    {
        /* ... */
    }

    public IEnumerable<string> Get()
    {
        /* ... */
        yield break;
    }
}

public class MySystem
{
    private readonly IRepository _repo; // contrato

    public MySystem(IRepository repo)
    {
        _repo = repo;
    }

    public void Run()
    {
        _repo.Save("Ana");
        foreach (var n in _repo.Get())
        {
            /* ... */
        }
    }
}

```

### Idea clave: cambiar de Names a NamesUnique, o a una implementación persistente, no requiere tocar MySystem si se respeta IRepository.

Ejemplo PostgreSQL (contratos de datos)
Contratos estables con vistas/funciones versionadas: la app consulta la vista, no las tablas físicas; los cambios internos se concentran en la definición de la vista.

Esquema mínimo:

```sql

CREATE SCHEMA shop;

CREATE TABLE shop.customers (
  id serial PRIMARY KEY,
  given_name text NOT NULL,
  family_name text NOT NULL,
  email text UNIQUE NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE shop.orders (
  id serial PRIMARY KEY,
  customer_id int NOT NULL REFERENCES shop.customers(id),
  amount_cents int NOT NULL,
  discount_cents int NOT NULL DEFAULT 0,
  shipping_cents int NOT NULL DEFAULT 0,
  created_at timestamptz NOT NULL DEFAULT now()
);
```

Contrato v1 (vista):

```sql

CREATE OR REPLACE VIEW shop.v_orders_summary_v1 AS
SELECT
  o.id AS order_id,
  c.id AS customer_id,
  (c.given_name || ' ' || c.family_name) AS customer_name,
  (o.amount_cents - o.discount_cents + o.shipping_cents) AS total_cents,
  o.created_at
FROM shop.orders o
JOIN shop.customers c ON c.id = o.customer_id;
```

Consumo:

```sql

SELECT order_id, customer_name, total_cents, created_at
FROM shop.v_orders_summary_v1;

```

Evolución:
- Si cambian nombres/columnas internas, actualiza la vista manteniendo las mismas columnas expuestas (contrato).
- Si el contrato debe cambiar (nombres/tipos), publica v2 y migra clientes en fases:
  1) Crear v2.
  2) Apuntar nuevos consumidores a v2.
  3) Migrar los existentes.
  4) Retirar v1 cuando no haya uso.

Ejemplo v2:

```sql 

CREATE OR REPLACE VIEW shop.v_orders_summary_v2 AS
SELECT
o.id AS order_id,
c.id AS customer_id,
jsonb_build_object('given', c.given_name, 'family', c.family_name) AS customer_name_json,
((o.amount_cents - o.discount_cents + o.shipping_cents) / 100.0)::numeric(12,2) AS total_amount,
o.created_at
FROM shop.orders o
JOIN shop.customers c ON c.id = o.customer_id;

```

### Mensaje clave: la vista no “se autocorrige” si cambian columnas internas; la ventaja es concentrar el ajuste en un solo punto (la definición de la vista) y mantener estable el contrato externo.

---

## Comparación: Capas vs. Componentes

| Aspecto | Capas | Componentes |
|---|---|---|
| Enfoque | Estructura horizontal por abstracción | Unidades modulares con interfaz |
| Objetivo | Separación de preocupaciones | Reemplazo, reutilización, testeo |
| Dependencias | Unidireccionales entre capas | A contratos entre componentes |
| Ejemplos | UI, Aplicación, Dominio, Infra | Service, Repository, Adapter |

---

## Patrones de diseño que favorecen bajo acoplamiento

| Patrón | Problema que resuelve | Cómo reduce acoplamiento | Enlace |
|---|---|---|---|
| Repository | Evitar que la lógica conozca DB/ORM | UI/servicios dependen de interfaz de datos | https://martinfowler.com/eaaCatalog/repository.html |
| Adapter | Proveedor/SDK con interfaz distinta | Adapta a un contrato interno estable | https://refactoring.guru/design-patterns/adapter |
| Strategy | Variar algoritmos sin tocar cliente | Selección por interfaz en tiempo de ejecución | https://refactoring.guru/design-patterns/strategy |
| Facade | Subsistema complejo a clientes | API simple que oculta detalles internos | https://refactoring.guru/design-patterns/facade |
| Dependency Injection | Evitar new de clases concretas | Composición externa une contratos-implementaciones | https://martinfowler.com/articles/injection.html |
| Factory / Abstract Factory | Crear familias sin acoplarse a clases | Construcción vía interfaces/creadores abstractos | https://refactoring.guru/design-patterns/abstract-factory |
| Observer / Pub-Sub | Notificaciones desacopladas | Emisor ignora suscriptores concretos | https://refactoring.guru/design-patterns/observer |
| CQRS | Lectura/escritura con necesidades distintas | Contratos separados y optimizados por flujo | https://martinfowler.com/bliki/CQRS.html |

Notas:
- Repository + Adapter suelen ir juntos: repositorio define el puerto, adaptadores mapean proveedores (ORM, HTTP, etc.).
- DI permite “enchufar” Strategy/Adapter/Repository sin tocar casos de uso.

---

## Checklist de calidad (rápido)

- UI depende de servicios/repositorios, no de SDK/DB.
- Servicios dependen de interfaces; implementaciones se inyectan.
- DTOs/contratos explícitos entre capas; no filtrar entidades internas.
- Datos expone vistas/funciones versionadas y estables.
- Cambios internos requieren editar un único adaptador/vista, no la app.

---

## Mini guion didáctico

1) Mostrar UI acoplada (consulta directa o fetch directo) y romperla renombrando “subtotal” → “amount”; discutir costo del cambio.  
2) Introducir interfaz/repositorio o vista/función; repetir el cambio y evidenciar que solo se ajusta el adaptador/definición, la UI permanece.  
3) Versionado: publicar v2, migrar en lotes, retirar v1; explicar cómo esto reduce riesgo y downtime.

---

## Mensaje final

Capas y componentes establecen límites claros; depender de contratos estables y aplicar patrones como Repository, Adapter, Strategy y DI reduce acoplamiento, permite evolucionar tecnología y facilita pruebas. Este enfoque maximiza mantenibilidad y velocidad de entrega en proyectos reales.